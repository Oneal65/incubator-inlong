/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.inlong.agent.core.task;

import org.apache.inlong.agent.common.AbstractDaemon;
import org.apache.inlong.agent.conf.AgentConfiguration;
import org.apache.inlong.agent.conf.JobProfile;
import org.apache.inlong.agent.core.AgentManager;
import org.apache.inlong.agent.db.JobProfileDb;
import org.apache.inlong.agent.utils.AgentUtils;
import org.apache.inlong.agent.utils.HttpManager;
import org.apache.inlong.agent.utils.ThreadUtils;
import org.apache.inlong.common.dbsync.position.LogPosition;
import org.apache.inlong.common.heartbeat.DbSyncTaskPositionMsg;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import static org.apache.inlong.agent.constant.CommonConstants.DUMP_POSITION_SUFFIX;
import static org.apache.inlong.agent.constant.CommonConstants.MAX_POSITION_SUFFIX;
import static org.apache.inlong.agent.constant.CommonConstants.POSITION_SUFFIX;
import static org.apache.inlong.agent.constant.CommonConstants.SEND_POSITION_SUFFIX;
import static org.apache.inlong.agent.constant.FetcherConstants.AGENT_HEARTBEAT_INTERVAL;
import static org.apache.inlong.agent.constant.FetcherConstants.AGENT_MANAGER_VIP_HTTP_HOST;
import static org.apache.inlong.agent.constant.FetcherConstants.AGENT_MANAGER_VIP_HTTP_PORT;
import static org.apache.inlong.agent.constant.FetcherConstants.AGENT_MANAGER_VIP_HTTP_PREFIX_PATH;
import static org.apache.inlong.agent.constant.FetcherConstants.DBSYNC_REPORT_TASK_POSITION;
import static org.apache.inlong.agent.constant.FetcherConstants.DBSYNC_TASK_POSITION_INTERVAL;
import static org.apache.inlong.agent.constant.FetcherConstants.DEFAULT_AGENT_FETCHER_INTERVAL;
import static org.apache.inlong.agent.constant.FetcherConstants.DEFAULT_AGENT_MANAGER_VIP_HTTP_PREFIX_PATH;
import static org.apache.inlong.agent.constant.FetcherConstants.DEFAULT_DBSYNC_REPORT_TASK_POSITION;
import static org.apache.inlong.agent.constant.FetcherConstants.DEFAULT_TASK_POSITION_INTERVAL;

/**
 * used to store task position to db, task position is stored as properties in JobProfile.
 * where key is task read file name and value is task sink position
 * note that this class is generated
 */
public class TaskPositionManager extends AbstractDaemon {

    private static final Logger LOGGER = LoggerFactory.getLogger(TaskPositionManager.class);
    private static volatile TaskPositionManager taskPositionManager = null;
    private final AgentManager agentManager;
    private final JobProfileDb jobConfDb;
    private final AgentConfiguration conf;
    private ConcurrentHashMap<String, ConcurrentHashMap<String, Long>> jobTaskPositionMap;
    private final Boolean isDbSync;
    private final HttpManager httpManager;
    private final String reportTaskPositionMsgUrl;
    private final ConcurrentHashMap<String, LogPosition> jobSenderPosition;
    private final ConcurrentHashMap<String, LogPosition> jobNewestPosition;
    private final ConcurrentHashMap<String, LogPosition> sendPosition;

    private Random random = new Random();

    private TaskPositionManager(AgentManager agentManager, Boolean isDbSync) {
        this.conf = AgentConfiguration.getAgentConf();
        this.agentManager = agentManager;
        this.jobConfDb = agentManager.getJobManager().getJobConfDb();
        this.jobTaskPositionMap = new ConcurrentHashMap<>();
        this.isDbSync = isDbSync;
        this.jobSenderPosition = new ConcurrentHashMap<>();
        this.jobNewestPosition = new ConcurrentHashMap<>();
        this.sendPosition = new ConcurrentHashMap<>();
        if (isDbSync) {
            this.httpManager = new HttpManager(conf);
            this.reportTaskPositionMsgUrl = buildReportDbSyncTaskPositionMsgUrl(buildBaseUrl());
        } else {
            this.httpManager = null;
            this.reportTaskPositionMsgUrl = null;
        }
    }

    private TaskPositionManager(AgentManager agentManager) {
        this(agentManager, false);
    }

    /**
     * task position manager singleton, can generated by agent manager and isDbSync
     */
    public static TaskPositionManager getTaskPositionManager(AgentManager agentManager, Boolean isDbSync) {
        if (taskPositionManager == null) {
            synchronized (TaskPositionManager.class) {
                if (taskPositionManager == null) {
                    taskPositionManager = new TaskPositionManager(agentManager, isDbSync);
                }
            }
        }
        return taskPositionManager;
    }

    /**
     * task position manager singleton, can only generated by agent manager
     */
    public static TaskPositionManager getTaskPositionManager(AgentManager agentManager) {
        return getTaskPositionManager(agentManager, false);
    }

    /**
     * get taskPositionManager singleton
     */
    public static TaskPositionManager getTaskPositionManager() {
        if (taskPositionManager == null) {
            throw new RuntimeException("task position manager has not been initialized by agentManager");
        }
        return taskPositionManager;
    }

    @Override
    public void start() throws Exception {
        submitWorker(taskPositionFlushThread());
    }

    private Runnable taskPositionFlushThread() {
        return () -> {
            while (isRunnable()) {
                try {
                    if (isDbSync) {
                        // when the mode is DbSync
                        // TODO: need jobTaskPositionMap whether or not
                        for (String jobId : jobSenderPosition.keySet()) {
                            JobProfile jobProfile = jobConfDb.getJobById(jobId);
                            if (jobProfile == null) {
                                LOGGER.warn("jobProfile {} cannot be found in db, might be deleted by "
                                                + "standalone mode, now delete job position in memory",
                                        jobId);
                                deleteJobPosition(jobId);
                                continue;
                            }
                            flushDbSyncJobProfile(jobId, jobProfile);
                        }
                        long baseInterval = conf.getLong(DBSYNC_TASK_POSITION_INTERVAL,
                                DEFAULT_TASK_POSITION_INTERVAL);
                        TimeUnit.MILLISECONDS.sleep(dbSyncInterval(baseInterval));
                    } else {
                        // check pending jobs and try to submit again.
                        for (String jobId : jobTaskPositionMap.keySet()) {
                            JobProfile jobProfile = jobConfDb.getJobById(jobId);
                            if (jobProfile == null) {
                                LOGGER.warn("jobProfile {} cannot be found in db, might be deleted by "
                                                + "standalone mode, now delete job position in memory",
                                        jobId);
                                deleteJobPosition(jobId);
                                continue;
                            }
                            flushJobProfile(jobId, jobProfile);
                        }
                        int flushTime = conf.getInt(AGENT_HEARTBEAT_INTERVAL,
                                DEFAULT_AGENT_FETCHER_INTERVAL);
                        TimeUnit.SECONDS.sleep(flushTime);
                    }
                } catch (Throwable ex) {
                    LOGGER.error("error caught", ex);
                    ThreadUtils.threadThrowableHandler(Thread.currentThread(), ex);
                }
            }
        };
    }

    private void flushJobProfile(String jobId, JobProfile jobProfile) {
        jobTaskPositionMap.get(jobId).forEach(
                (fileName, position) -> jobProfile.setLong(fileName + POSITION_SUFFIX, position)
        );
        if (jobConfDb.checkJobfinished(jobProfile)) {
            LOGGER.info("Cannot update job profile {}, delete memory job in jobTaskPosition", jobId);
            deleteJobPosition(jobId);
        } else {
            jobConfDb.updateJobProfile(jobProfile);
        }
    }

    private void flushDbSyncJobProfile(String jobId, JobProfile jobProfile) {
        // update jobProfile and Db
        LogPosition dumpPosition = getJobSenderPosition(jobId);
        LogPosition sendPosition = getSendPositionPosition(jobId);
        LogPosition maxLogPosition = getJobNewestPosition(jobId);
        jobProfile.set(jobId + DUMP_POSITION_SUFFIX, dumpPosition.toString());
        jobProfile.set(jobId + SEND_POSITION_SUFFIX, sendPosition.toString());
        jobProfile.set(jobId + MAX_POSITION_SUFFIX, maxLogPosition.toString());
        if (jobConfDb.checkJobfinished(jobProfile)) {
            LOGGER.info("Cannot update job profile {}, delete memory job in jobTaskPosition", jobId);
            deleteJobPosition(jobId);
        } else {
            jobConfDb.updateJobProfile(jobProfile);
        }

        // send to manager
        final String agentIp = AgentUtils.fetchLocalIp();
        DbSyncTaskPositionMsg taskPositionMsg = new DbSyncTaskPositionMsg();
        taskPositionMsg.setInstance(agentIp);
        // TODO: how to get these values
        taskPositionMsg.setServerId(null);
        taskPositionMsg.setTaskIds(null);
        taskPositionMsg.setDumpPosition(dumpPosition);
        taskPositionMsg.setSendPosition(sendPosition);
        taskPositionMsg.setMaxLogPosition(maxLogPosition);
        taskPositionMsg.setReportTime(System.currentTimeMillis());

        reportDbSyncTaskPositionMsg(taskPositionMsg);
    }

    public void reportDbSyncTaskPositionMsg(DbSyncTaskPositionMsg taskPositionMsg) {
        httpManager.doSentPost(reportTaskPositionMsgUrl, taskPositionMsg);
    }

    /**
     * build base url for manager according to config
     *
     * example - http://127.0.0.1:8080/inlong/manager/openapi
     */
    private String buildBaseUrl() {
        return "http://" + conf.get(AGENT_MANAGER_VIP_HTTP_HOST)
                + ":" + conf.get(AGENT_MANAGER_VIP_HTTP_PORT)
                + conf.get(AGENT_MANAGER_VIP_HTTP_PREFIX_PATH, DEFAULT_AGENT_MANAGER_VIP_HTTP_PREFIX_PATH);
    }

    private String buildReportDbSyncTaskPositionMsgUrl(String baseUrl) {
        return baseUrl + conf.get(DBSYNC_REPORT_TASK_POSITION, DEFAULT_DBSYNC_REPORT_TASK_POSITION);
    }

    private void deleteJobPosition(String jobId) {
        jobTaskPositionMap.remove(jobId);
    }

    @Override
    public void stop() throws Exception {
        waitForTerminate();
    }

    /**
     * update job sink position
     *
     * @param size add this size to beforePosition
     */
    public void updateSinkPosition(String jobInstanceId, String sourcePath, long size) {
        ConcurrentHashMap<String, Long> positionTemp = new ConcurrentHashMap<>();
        ConcurrentHashMap<String, Long> position = jobTaskPositionMap.putIfAbsent(jobInstanceId, positionTemp);
        if (position == null) {
            position = positionTemp;
        }
        Long beforePosition = position.getOrDefault(sourcePath, 0L);
        position.put(sourcePath, beforePosition + size);
    }

    public void updateJobSenderPosition(String jobName, LogPosition jobPosition) {
        jobSenderPosition.put(jobName, jobPosition);
    }

    public LogPosition getJobSenderPosition(String jobName) {
        return jobSenderPosition.get(jobName);
    }

    public void updateJobNewestPosition(String jobName, LogPosition jobPosition) {
        jobNewestPosition.put(jobName, jobPosition);
    }

    public LogPosition getJobNewestPosition(String jobName) {
        return jobNewestPosition.get(jobName);
    }

    public void updateSendPositionPosition(String jobName, LogPosition jobPosition) {
        sendPosition.put(jobName, jobPosition);
    }

    public LogPosition getSendPositionPosition(String jobName) {
        return sendPosition.get(jobName);
    }

    public ConcurrentHashMap<String, Long> getTaskPositionMap(String jobId) {
        return jobTaskPositionMap.get(jobId);
    }

    public ConcurrentHashMap<String, ConcurrentHashMap<String, Long>> getJobTaskPosition() {
        return jobTaskPositionMap;
    }

    /**
     * Default heartbeat interval is  3 * 60 * 1000, unit is MILLISECONDS.
     *
     * @return interval in MILLISECONDS
     */
    private long dbSyncInterval(long baseInterval) {
        return baseInterval + ((long) (random.nextFloat() * baseInterval / 2));
    }
}
